学习笔记
Hashmap
python 中使用字典来实现 hashmap
底层使用hash表的方式来加快查找速度 最快o（1)的查找速度，处理哈希冲突使用的是开放寻址法，java的hashmap 处理哈希冲突使用拉链法。

开放寻址法
简单地讲，也就是说，一间厕所，来了一个顾客就蹲其对应的位置，如果又来一个顾客，把厕所单间门拉开，一看里
面有位童鞋正在用劲，那么怎么办？很自然的，拉另一个单间的门，看看有人不，有的话就继续找坑。当然了，一般来说，
这个顾客不会按顺序一个一个地拉厕所门，而是会去拉他认为有可能没有被占用的单间的门，这可以通过闻味道，听声音
来辨别，这就是寻址查找算法。如果找遍了所有厕所单间，看尽了所有人的光屁股，还是找不到坑，那么这座厕所就该扩
容了。当然了，厕所扩容不会就只单单增加一个坑位，而是综合考虑成本和保证不让太多顾客拉到裤子里，会多增加几个
坑位，比如增加现有坑位的0.72倍。为什么是0.72呢，这是所长多年经营所得到的经验值，为了让自己的经验发扬光大，
需要出去演讲，又不能太俗，总不能说“厕所坑位因子”吧，那就把把0.72叫做“装填因子”或者“扩容因子”吧。目
前很多产品使用0.72这个常数。

优点

记录更容易进行序列化（serialize）操作
如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的
缺点

存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷
使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低
由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费
删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。


拉链法
遇到冲突将待存储的值使用链表的方式插入到哈希值对应存储位置的链表的最后
查找依次循环 查找直到找到并返回

优点

对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销）
由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了
删除记录时，比较方便，直接通过指针操作即可
缺点

存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销
如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列
由于使用指针，记录不容易进行序列化（serialize）操作


其中有很重要的两个参数影响其性能: 初始容量和加载因子

dict：默认初始容量为8，加载因子为2/3

HashMap： 默认初始容量为16， 加载因子为0.75


两者相同的是扩容的长度必需是2的N次方
